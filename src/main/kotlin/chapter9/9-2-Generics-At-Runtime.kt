package chapter9

import java.lang.IllegalArgumentException
import java.util.*

fun main() {

    // consider
    val list1: List<String> = listOf("1", "2", "3")
    val list2: List<Int> = listOf(1, 2, 3)
    // for both lists, the type argument is erased. Only that they are Lists is known
    // Only the compiler knows the types of the lists, and makes sure that we can only add the appropriate type

    // even though the type is erased, and we cannot check for e.g. if (list1 is List<String>) {...} we can do this
    if (list1 is List<*>) {}


    // this code is problematic. Because we do not know the type of the list, the code will work fine with a list that
    // actually contains integers. But we will have a ClassCastException (Not an IllegalArgumentException!) if we pass
    // a list of string. We can't check whether the list is a List<Int>, so the cast succeeds, we call sum() on the collection
    // and get a CCE as result.
    fun printSum(c: Collection<*>) {
        val intList = c as? List<Int> ?: throw IllegalArgumentException("List is expected")
        println(intList.sum())
    }

    // if the type is known at compile time we have no such problem
    fun printIntSum(c: Collection<Int>) {
        if (c is List<Int>) {
            println(c.sum())
        }
    }

    // this implementation would not compile as the type of T is erased at runtime
    // inline fun <T> isA(value: Any) = value is T

    // however, the reified keyword allows us to retain the type information at runtime. Reified can only(?) be used
    // with inline functions (which are inserted as in into the generated bytecode, rather than referenced). This allows 
    // the preservation of the type, as the generated bytecode at compilation time still contains the required info
    println(isA<String>("ABC"))

    // the filterIsInstance library method is has a reified T param which allows us to check the type at runtime
    val mixedList = listOf(1, "2", 3)
    println(mixedList.filterIsInstance<Int>())
    
    // another example where reified type params can be useful is when using Java code that requires a java.lang.Class
    val service = ServiceLoader.load(SomeClass::class.java)
    
    // a streamlined implementation
    val service2 = loadService<SomeClass>()

}

inline fun <reified T> isA(value: Any) = value is T

// a simplified implementation of filterIsInstance
inline fun <reified T> Iterable<*>.filterIsInstance(): List<T> {
    val destination = mutableListOf<T>()
    for (item in this) {
        if (item is T) {
            destination.add(item)
        }
    }
    return destination
}

inline fun <reified T> loadService(): ServiceLoader<T> = ServiceLoader.load(T::class.java)


class SomeClass 